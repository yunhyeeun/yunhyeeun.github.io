I"µ<p><br />
Graph : vertex + edge</p>

<p>undirected edge vs directed edge : edgeì˜ ë°©í–¥ì„±ìœ ë¬´</p>

<ul>
  <li>in-degree : vertexë¡œ ë“¤ì–´ì˜¤ëŠ” edgeì˜ ìˆ˜</li>
  <li>out-degree : vertexì—ì„œ ë‚˜ê°€ëŠ” edgeì˜ ìˆ˜</li>
</ul>

<h2 id="ê·¸ë˜í”„-êµ¬í˜„-ë°©ë²•">ê·¸ë˜í”„ êµ¬í˜„ ë°©ë²•</h2>

<ol>
  <li>
    <p>Edge list <br />
Edgeì˜ ê°œìˆ˜ê°€ Eì¼ ê²½ìš° E * 2(3) ì´ì°¨ì› array ìƒì„± <br />
Edge ë³„ vertex ì •ë³´ì™€ weight ì €ì¥</p>
  </li>
  <li>
    <p>Adjacency matrix <br />
vertex ê°œìˆ˜ê°€ Vì¼ ê²½ìš° V * V ì´ì°¨ì› array ìƒì„± <br />
vertex ê°„ edgeê°€ ìˆë‹¤ë©´ 1, ì—†ìœ¼ë©´ 0 ì €ì¥(weightê°€ ìˆë‹¤ë©´ weight ì €ì¥) <br />
vertex ê°€ ë§ìœ¼ë©´ ë©”ëª¨ë¦¬ ë‚­ë¹„</p>
  </li>
  <li>
    <p>Adjacent list <br />
vertex ê°œìˆ˜ê°€ Vì¼ ê²½ìš° Vê°œì˜ list ìƒì„± <br />
ê° list ë³„ ì—°ê²°ëœ vertex ì •ë³´ ì €ì¥
dijestraì— ì´ìš©</p>
  </li>
</ol>

<h2 id="union-find">Union-Find</h2>

<p>Disjoint Set : ì„œë¡œì†Œ ì§‘í•©
Union(x, y) : xê°€ ì†í•œ ì§‘í•©ê³¼ yê°€ ì†í•œ ì§‘í•©ì„ í•©ì¹œë‹¤
Find(x) : xê°€ ì†í•œ ì§‘í•©ì˜ ëŒ€í‘œê°’ì„ return</p>
<ul>
  <li>ì£¼ë¡œ treeë¡œ êµ¬í˜„
<br />
<a href="https://www.acmicpc.net/problem/1717">ë°±ì¤€ 1717 ì§‘í•©ì˜ í‘œí˜„</a></li>
</ul>

<p>union-findë¥¼ êµ¬í˜„í•˜ëŠ” ë¬¸ì œì´ë‹¤. íŠ¸ë¦¬ë¥¼ ì“°ì§€ ì•Šê³  ì§‘í•©ì˜ ëŒ€í‘œê°’ì„ ì €ì¥í•˜ëŠ” ë°°ì—´ë§Œ ì‚¬ìš©í•´ë„ í†µê³¼í•  ìˆ˜ ìˆë‹¤.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>N = Integer.parseInt(st.nextToken());
M = Integer.parseInt(st.nextToken());
parent = new int[N + 1];
for (int i = 1;i &lt;= N;i++) {
    parent[i] = i;
}
for (int i = 0;i &lt; M;i++) {
    st = new StringTokenizer(br.readLine());
    int func = Integer.parseInt(st.nextToken());
    int a = Integer.parseInt(st.nextToken());
    int b = Integer.parseInt(st.nextToken());
    // union
    if (func == 0) {
        union(a, b);
    }
    // find
    else {
        int aRoot = find(a);
        int bRoot = find(b);
        if (aRoot == bRoot) {
            System.out.println("YES");
        } else {
            System.out.println("NO");
        }
    }
}
</code></pre></div></div>
<p><br />
<a href="https://www.acmicpc.net/problem/3830">ë°±ì¤€ 3830 êµìˆ˜ë‹˜ì€ ê¸°ë‹¤ë¦¬ì§€ ì•ŠëŠ”ë‹¤</a></p>

<p>ì´ ë¬¸ì œë„ union-findë¥¼ êµ¬í˜„í•˜ëŠ” ë¬¸ì œë‹¤. ìœ„ ë¬¸ì œì™€ ì°¨ì´ì ì€ ë¬´ê²Œì— ëŒ€í•œ ì •ë³´ì— ëŒ€í•´ì„œë„ union-findë¥¼ í•´ì•¼í•˜ëŠ”ë° ì´ë¥¼ ê³„ì‚°í•˜ëŠ” ì‹ì„ ìƒê°í•˜ê¸° ì–´ë ¤ì› ë‹¤.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>while (true) {
    st= new StringTokenizer(br.readLine());
    N = Integer.parseInt(st.nextToken());
    M = Integer.parseInt(st.nextToken());
    if (N == 0 &amp;&amp; M == 0) {
        break;
    }
    parent = new int[N + 1];
    weight = new int[N + 1];
    for (int i = 1;i &lt;= N;i++) {
        parent[i] = i;
    }
    for (int i = 0;i &lt; M;i++) {
        String[] inputs = br.readLine().split(" ");
        if (inputs[0].equals("!")) {
            int a = Integer.parseInt(inputs[1]);
            int b = Integer.parseInt(inputs[2]);
            int w = Integer.parseInt(inputs[3]);
            measure(a, b, w);
        } else {
            int a = Integer.parseInt(inputs[1]);
            int b = Integer.parseInt(inputs[2]);
            check(a, b);
        }
    }
}

public static void check(int a, int b) {
    if (find(a) != find(b)) {
        System.out.println("UNKNOWN");
    } else {
        System.out.println(weight[b] - weight[a]);
    }
}
public static void measure(int a, int b, int w) {
    int aRoot = find(a);
    int bRoot = find(b);
    if (aRoot != bRoot) {
        parent[bRoot] = aRoot;
        weight[bRoot] = weight[a] - weight[b] + w;
    }
}

public static int find(int a) {
    if (parent[a] == a) {
        return a;
    } else {
        int tmp = find(parent[a]);
        weight[a] += weight[parent[a]];
        return parent[a] = find(parent[a]);
    }
}
</code></pre></div></div>

<h2 id="dagdirected-acyclic-graph">DAG(Directed Acyclic Graph)</h2>
<p>: ìˆœí™˜ì„ ê°€ì§€ì§€ ì•ŠëŠ” ë°©í–¥ê·¸ë˜í”„ <br />
ìœ„ìƒì •ë ¬ : DAGì—ì„œ ê·¸ë˜í”„ì˜ ë°©í–¥ì„±ì„ ê±°ìŠ¤ë¥´ì§€ ì•Šê³  vertexë¥¼ ë‚˜ì—´</p>
<BFS ì´ìš©="">   

1. in-degree(predecessor)ê°€ ì—†ìœ¼ë©´ enqueue   
2. enqueue ëœ predecessorê°€ ìˆëŠ” successorì˜ in-degreeë¥¼ -1   
3. predecessor == 0ì´ë©´ enqueue   
4. queueê°€ ë¹Œ ë•Œê¹Œì§€ ë°˜ë³µ   

<br />
[ë°±ì¤€ 2252 ì¤„ ì„¸ìš°ê¸°](https://www.acmicpc.net/problem/2252)

í‚¤ ìˆœìœ¼ë¡œ í•™ìƒë“¤ì„ ì¤„ì„ ì„¸ìš´ë‹¤ë©´ ì‘ì€ í•™ìƒì€ í° í•™ìƒì˜ predecessorê°€ ëœë‹¤. ì£¼ì–´ì§„ ì…ë ¥ê°’ì—ì„œ ìê¸°ë³´ë‹¤ ì‘ì€ í•™ìƒì˜ ìˆ˜ë¥¼ countí•œ í›„ BFSë¥¼ ì‹¤í–‰í•˜ë©´ ë‹µì„ êµ¬í•  ìˆ˜ ìˆë‹¤.

```
N = Integer.parseInt(st.nextToken());
M = Integer.parseInt(st.nextToken());
list = new ArrayList[N + 1];
indegree = new int[N + 1];
for (int i = 1;i &lt;= N;i++) {
    list[i] = new ArrayList&lt;&gt;();
}
for (int i = 0;i &lt; M;i++) {
    st = new StringTokenizer(br.readLine());
    int a = Integer.parseInt(st.nextToken());
    int b = Integer.parseInt(st.nextToken());
    list[a].add(b);
    indegree[b]++;
}

Queue<Integer> q = new LinkedList&lt;&gt;();
for (int i = 1;i &lt;= N;i++) {
    if (indegree[i] == 0) {
        q.add(i);
    }
}
while (true) {
    if (q.isEmpty()) {
        break;
    }
    int student = q.poll();
    sb.append(student);
    sb.append(" ");
    for (int next : list[student]) {
        indegree[next]--;
        if (indegree[next] == 0) {
            q.add(next);
        }
    }	
}
System.out.println(sb.toString());
```

</Integer></BFS>
:ET