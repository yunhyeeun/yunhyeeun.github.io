I"³0<p><br /></p>

<p>ì•Œê³ ë¦¬ì¦˜ì´ ë¬¸ì œë¥¼ í•´ê²°í•˜ëŠ” ë°©ë²•ì´ë¼ë©´ ì‹œê°„ë³µì¡ë„ëŠ” ë¬¸ì œë¥¼ í•´ê²°í•˜ëŠ”ë° ê±¸ë¦¬ëŠ” ì‹œê°„ì´ë‹¤. <br />
ì‚¬ì¹™ì—°ì‚°ì´ë‚˜ ì¡°ê±´ë¬¸ì˜ ì¡°ê±´ì„ ê³„ì‚°í•˜ëŠ” íšŸìˆ˜ì— ë”°ë¼ ì‹¤í–‰ì‹œê°„ì´ ê²°ì •ëœë‹¤.<br />
ì£¼ë¡œ ë°˜ë³µë¬¸ì˜ ë²”ìœ„ë‚˜ ì¤‘ì²© ë°˜ë³µë¬¸ì— ì˜í•´ ê²°ì •ëœë‹¤.</p>

<h2 id="ì‹œê°„ë³µì¡ë„">ì‹œê°„ë³µì¡ë„</h2>

<blockquote>
  <p>ì‹œê°„ë³µì¡ë„(time complexity)ëŠ” ì•Œê³ ë¦¬ì¦˜ì˜ ìˆ˜í–‰ì‹œê°„ì´ë‹¤.</p>
</blockquote>

<h3 id="time-complexity-í‘œê¸°ë²•">Time complexity í‘œê¸°ë²•</h3>

<ul>
  <li>big O : worst case</li>
  <li>big omega : best case</li>
  <li>big theta : average case</li>
</ul>

<p>ì¼ë°˜ì ìœ¼ë¡œ <strong>big-O notation</strong>ì„ ì‚¬ìš©í•œë‹¤. <br />
big-Oë¡œ í‘œê¸°í•  ë•Œ <em>ìµœê³ ì°¨í•­ì˜ ì°¨ìˆ˜</em>ë§Œì„ í‘œê¸°í•œë‹¤.</p>

<h3 id="time-complexity-ì¢…ë¥˜">Time complexity ì¢…ë¥˜</h3>

<ul>
  <li>O(1)</li>
  <li>O(logN)</li>
  <li>O(N)</li>
  <li>O(NlogN)</li>
  <li>O(N^2)</li>
  <li>O(N^3)</li>
  <li>O(2^N)</li>
  <li>O(N!)</li>
</ul>

<p>ì˜ˆ1. Binary Search : O(logN)</p>

<p>ì˜ˆ2. Merge Sort : O(NlogN) <br />
ë¶„í• (N) + ë³‘í•©(NlogN)</p>

<p>ì˜ˆ3. ê±°ë“­ì œê³± ë¹ ë¥´ê²Œ ì—°ì‚° : O(logN)  <br />
ì§€ìˆ˜ë¥¼ 2ì˜ ê±°ë“­ì œê³± í˜•íƒœë¡œ ë‚˜ëˆ„ì–´ ê³„ì‚°</p>

<h3 id="time-complexity-ë¹„êµ">Time complexity ë¹„êµ</h3>
<p>Nì´ ì»¤ì§ˆìˆ˜ë¡ ì°¨ì´ê°€ ì»¤ì§„ë‹¤.</p>

<table>
  <tbody>
    <tr>
      <td>ë¹ ë¦„</td>
      <td>Â </td>
      <td>Â </td>
      <td>Â </td>
      <td>Â </td>
      <td>Â </td>
      <td>ëŠë¦¼</td>
    </tr>
  </tbody>
  <tfoot>
    <tr>
      <td>1</td>
      <td>logN</td>
      <td>N</td>
      <td>NlogN</td>
      <td>N^2</td>
      <td>2^N</td>
      <td>N!</td>
    </tr>
  </tfoot>
</table>

<p><br /></p>

<h2 id="ê³µê°„ë³µì¡ë„space-complexity">ê³µê°„ë³µì¡ë„(Space Complexity)</h2>

<p>ê³µê°„ë³µì¡ë„ëŠ” ì•Œê³ ë¦¬ì¦˜ì˜ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ì— ê´€í•œ ì§€í‘œì´ë‹¤.</p>

<h3 id="ìë£Œí˜•-ë³„-ë©”ëª¨ë¦¬-í¬ê¸°java">ìë£Œí˜• ë³„ ë©”ëª¨ë¦¬ í¬ê¸°(java)</h3>

<ul>
  <li>ë¬¸ìí˜•(char) :  2byte</li>
  <li>ì •ìˆ˜í˜•(short) :  2byte</li>
  <li>ì •ìˆ˜í˜•(int) : 4byte</li>
  <li>ì •ìˆ˜í˜•(long) : 8byte</li>
  <li>ì†Œìˆ˜í˜•(float) : 4byte</li>
  <li>ì†Œìˆ˜í˜•(double) : 8byte</li>
</ul>

<h2 id="í”¼ë³´ë‚˜ì¹˜-ê³„ì‚°">í”¼ë³´ë‚˜ì¹˜ ê³„ì‚°</h2>

<p>ê°™ì€ ë¬¸ì œì—¬ë„ ì–´ë–¤ ì•Œê³ ë¦¬ì¦˜ì„ ì‚¬ìš©í•˜ëŠ”ì§€ì— ë”°ë¼ time complexity, space complexityê°€ ë‹¬ë¼ì§„ë‹¤. <br />
í”¼ë³´ë‚˜ì¹˜ ìˆ˜ì—´ì„ êµ¬í•˜ëŠ” ë¬¸ì œë¥¼ ì˜ˆì‹œë¡œ ì´ë¥¼ ì•Œì•„ë³´ì.</p>

<ul>
  <li>ì¼ë°˜ ì¬ê·€í•¨ìˆ˜ : O(2^N) <br />
Në¶€í„° 1ê¹Œì§€ ì—­ìœ¼ë¡œ ê³„ì‚°í•˜ëŠ” ë°©ë²•</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func fibonacci(N) {
    if (N &lt; 3) {
        return 1;
    }
    return fibonacci(N - 1) + fibonacci(N - 2);
}
</code></pre></div></div>

<ul>
  <li>ë°˜ë³µë¬¸ : O(N) <br />
1ë¶€í„° ê³„ì‚°í•˜ëŠ” ë°©ë²•</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func fibonacci(N) {
    int a = 1;
    int b =  1;
    int c = 1;
    for (int i = 2;i &lt; N;i++) {
        c = a + b;
        a = b;
        b = c;
    }
    return c;
}
</code></pre></div></div>

<ul>
  <li>dynamic programming : O(N) <br />
2ë²ˆì˜ ì¤‘ê°„ê²°ê³¼ê°’ì„ ì €ì¥ (ë¯¸ë¦¬ ì €ì¥ëœ ê°’ì˜ ê²½ìš° O(1))</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int[] dp = new dp[N + 1];
func fibonacci(N) {
    dp[1] = 1;
    dp[2] = 1;
    int a = 1;
    int b =  1;
    int c = 1;
    for (int i = 2;i &lt; N;i++) {
        c = a + b;
        a = b;
        b = c;
        dp[i + 1] = c;
    }
    return c;
}
</code></pre></div></div>

<ul>
  <li>í–‰ë ¬ì˜ ê±°ë“­ì œê³± : O(logN)</li>
</ul>

<h2 id="ë°±ì¤€-2003ë²ˆ-ìˆ˜ë“¤ì˜-í•©2"><a href="https://www.acmicpc.net/problem/2003">ë°±ì¤€ 2003ë²ˆ ìˆ˜ë“¤ì˜ í•©2</a></h2>

<p>ë¬¸ì œ ì„¤ëª…ëŒ€ë¡œ ìˆ˜ì—´ì˜ ë¶€ë¶„í•©ì„ êµ¬í•˜ë©´ time complexityëŠ” O(N^2)ì´ë‹¤. <br />
<strong>íˆ¬í¬ì¸í„°</strong>ë¥¼ ì‚¬ìš©í•˜ë©´ ì´ë¥¼ ì¤„ì¼ ìˆ˜ ìˆë‹¤. <br />
ë¬¸ì œí’€ì´ì— í•µì‹¬ì ì¸ ìš”ì†Œë¥¼ ì •ë¦¬í•´ë³´ì•˜ë‹¤.</p>

<ul>
  <li>low index pointerì™€ high index pointerë¥¼ ì§€ì •í•œë‹¤.</li>
  <li>ìˆ˜ì—´ì€ ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ì •ë ¬ëœ ìƒíƒœì´ë‹¤</li>
  <li>ë¶€ë¶„í•©ì´ targetë³´ë‹¤ ì‘ìœ¼ë©´ high pointerë¥¼ ì¦ê°€ì‹œí‚¨ë‹¤.</li>
  <li>ë¶€ë¶„í•©ì´ targetë³´ë‹¤ í¬ë©´ low pointerë¥¼ ì¦ê°€ì‹œí‚¨ë‹¤.</li>
  <li>high pointerê°€ ë²”ìœ„ë¥¼ ë²—ì–´ë‚  ë•Œê¹Œì§€ ë°˜ë³µí•œë‹¤.</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>while (high &lt; N) {
    // ë¶€ë¶„í•©ì´ targetë³´ë‹¤ ì‘ì„ ë•Œ
    if (sum &lt; M) {
        // high pointer ì¦ê°€
        high++;
        if (high == N) break;
        sum += array[high];
    } else if (sum == M) {
        answer++;
        high++;
        if (high == N) break;
        sum += array[high];
    }
    // ë¶€ë¶„í•©ì´ targetë³´ë‹¤ í´ ë•Œ
    else {
        sum -= array[low];
        // low pointer ì¦ê°€
        low++;
        if (low &gt; high) {
            high++;
            if (high == N) break;
            sum = array[high];
        }
    }
}

</code></pre></div></div>

<p>ìœ ì‚¬í•œ ë¬¸ì œ <a href="https://www.acmicpc.net/problem/1806">ë°±ì¤€ 1806ë²ˆ ë¶€ë¶„í•©</a></p>

<h2 id="ë°±ì¤€-2805ë²ˆ-ë‚˜ë¬´ìë¥´ê¸°"><a href="https://www.acmicpc.net/problem/2805">ë°±ì¤€ 2805ë²ˆ ë‚˜ë¬´ìë¥´ê¸°</a></h2>

<p>ê°€ì¥ ë†’ì€ ë‚˜ë¬´ì˜ ë†’ì´ë¶€í„° 0ê¹Œì§€ ì°¨ë¡€ëŒ€ë¡œ ê³„ì‚°í•˜ë©´ O(N)ì˜ time complexityë¡œ ë¬¸ì œë¥¼ í•´ê²°í•  ìˆ˜ ìˆë‹¤. <br />
í•˜ì§€ë§Œ <strong>binary search</strong>ë¥¼ ì‚¬ìš©í•˜ë©´ ì´ë¥¼ O(logN)ìœ¼ë¡œ ì¤„ì¼ ìˆ˜ ìˆë‹¤.</p>

<ul>
  <li>ë°°ì—´ì€ ì •ë ¬ë˜ì–´ìˆë‹¤.</li>
  <li>ë°°ì—´ì˜ ì‹œì‘ì (low)ê³¼ ëì (high)ì˜ ì¤‘ê°„ê°’ midë¥¼ êµ¬í•œë‹¤</li>
  <li>targetì´ midë³´ë‹¤ ì‘ë‹¤ë©´ highë¥¼ mid-1ë¡œ ìˆ˜ì •í•œë‹¤</li>
  <li>targetì´ midë³´ë‹¤ í¬ë‹¤ë©´ lowë¥¼ mid + 1ë¡œ ìˆ˜ì •í•œë‹¤</li>
  <li>lowê°€ highë³´ë‹¤ ì»¤ì§ˆ ë•Œê¹Œì§€ ë°˜ë³µí•œë‹¤</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>while (low &lt;= high) {
    mid = (high + low) / 2;
    sum = 0;
    for (int i = 0; i &lt; N; i++) {
        sum += Math.max(trees[i] - mid, 0);
    }
    // sumì´ Më³´ë‹¤ í° ê²½ìš° -&gt; low = mid + 1
    if (sum &gt;= M) {
        low = mid + 1;
        answer = Math.max(answer, mid);
    }
    // sumì´ Më³´ë‹¤ ì‘ì€ ê²½ìš° -&gt; high = mid - 1
    else {
        high = mid - 1;
    }
}
</code></pre></div></div>

<h2 id="ë°±ì¤€-2143ë²ˆ-ë‘-ë°°ì—´ì˜-í•©"><a href="https://www.acmicpc.net/problem/2143">ë°±ì¤€ 2143ë²ˆ ë‘ ë°°ì—´ì˜ í•©</a></h2>

<p>ë¶€ë¶„í•© ë¬¸ì œì™€ ë¹„ìŠ·í•˜ì§€ë§Œ ë°°ì—´ì´ ë‘ ê°œë¼ëŠ” ì°¨ì´ì ì´ ìˆë‹¤. <br />
ì™„ì „íƒìƒ‰ìœ¼ë¡œ í’€ë ¤ê³  í•˜ë©´ time complexityê°€ O(N^4)ì •ë„ ë‚˜ì˜¤ëŠ”ë° ë‹¤ë¥¸ ë°©ë²•ì„ ì°¾ì•„ë³´ì. <br />
ê° ë°°ì—´ì˜ ëª¨ë“  ë¶€ë¶„í•©ì„ ì €ì¥í•œ ë°°ì—´ì„ ë§Œë“¤ì–´ ì •ë ¬í•˜ê³  ë§Œë“¤ì–´ì§„ ë‘ ë¶€ë¶„í•© ë°°ì—´ì„ ê³ ë ¤í•˜ë©´ time complexityë¥¼ ì¤„ì¼ ìˆ˜ ìˆë‹¤.</p>

<ol>
  <li>ë¶€ë¶„í•© ë°°ì—´ ë§Œë“¤ì–´ ì •ë ¬ : O(N^2)</li>
  <li>í•œ ë°°ì—´ì„ ê¸°ì¤€ìœ¼ë¡œ íˆ¬í¬ì¸í„°ë¥¼ ì‚¬ìš©í•˜ì—¬ binary searchë¡œ ê³„ì‚° : O(NlogN)</li>
</ol>

<p>ì´ ë•Œ íˆ¬í¬ì¸í„°ëŠ” ìœ„ low, highê°€ ì•„ë‹ˆë¼ lower bound&amp;upper bound ê°œë…ì„ ë§í•œë‹¤.</p>

<ul>
  <li>lower bound : ì°¾ê³ ìí•˜ëŠ” ê°’ ì´ìƒì´ ì²˜ìŒ ë‚˜íƒ€ë‚˜ëŠ” ìœ„ì¹˜</li>
  <li>upper bound : ì°¾ê³ ìí•˜ëŠ” ê°’ë³´ë‹¤ í° ê°’ì´ ì²˜ìŒìœ¼ë¡œ ë‚˜íƒ€ë‚˜ëŠ” ìœ„ì¹˜</li>
</ul>

<p>ë‹¤ì‹œ ë§í•´, í•œ ë¶€ë¶„í•© ë°°ì—´ì„ ìˆœíšŒí•˜ë©´ì„œ(A[i]) ë‚˜ë¨¸ì§€ ë¶€ë¶„í•© ë°°ì—´ì—ì„œ target-A[i] ê°’ì„ countí•˜ë©´ ëœë‹¤. <br />
ê·¸ë¦¬ê³  ê·¸ ê°’ì€ <strong>upper bound - lower bound</strong>ì´ë‹¤.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>subA = getSubarray(A);
subB = getSubarray(B);

Collections.sort(subB);

// ì–´ì°¨í”¼ subAë¥¼ ìˆœíšŒí•˜ê¸° ë•Œë¬¸ì— subAëŠ” sortí•  í•„ìš”ê°€ ì—†ë‹¤
for (int i = 0;i &lt; subA.size();i++) {
    long target = T - subA.get(i);
    answer += upperBound(target, subB) - lowerBound(target, subB);
}

public static int upperBound(long target, List&lt;Long&gt;array) {
    int low = 0;
    int high = array.size();
    while (low &lt; high) {
        int mid = (low + high) / 2;
        // low, highë¥¼ ìˆ˜ì •í•˜ëŠ” ë¶€ë¶„ì„ ì–¸ì œë‚˜ í—·ê°ˆë¦¬ë‹ˆ ìœ ì˜í•˜ì
        if (subB.get(mid) &lt;= target) {
            low = mid + 1;
        } else {
            high = mid;
        }
    }
    return low;
}

public static int lowerBound(long target, List&lt;Long&gt;array) {
    int low = 0;
    int high = array.size();
    while (low &lt; high) {
        int mid = (low + high) / 2;
        // low, highë¥¼ ìˆ˜ì •í•˜ëŠ” ë¶€ë¶„ì„ ì–¸ì œë‚˜ í—·ê°ˆë¦¬ë‹ˆ ìœ ì˜í•˜ì
        if (subB.get(mid) &lt; target) {
            low = mid + 1;
        } else {
            high = mid;
        }
    }
    return low;
}

public static List&lt;Long&gt; getSubarray(int[] array) {
    List&lt;Long&gt; subarray = new ArrayList&lt;Long&gt;();
    for (int i = 0;i &lt; array.length;i++) {
        long sum = 0;
        for (int j = i;j &lt; array.length;j++) {
            sum += array[j];
            subarray.add(sum);
        }
    }
    return subarray;
}
</code></pre></div></div>
<p>ì´ ë¬¸ì œì—ì„œ ë‹µì´ intì˜  maxvalueë¥¼ ì´ˆê³¼í•˜ê¸° ë•Œë¬¸ì— longìœ¼ë¡œ ì •ì˜í•´ì•¼ í†µê³¼í•œë‹¤.</p>

<h2 id="ë°±ì¤€-2517ë²ˆ-ë‹¬ë¦¬ê¸°"><a href="https://www.acmicpc.net/problem/2143">ë°±ì¤€ 2517ë²ˆ ë‹¬ë¦¬ê¸°</a></h2>

<p>ë‚´ ì• ì‚¬ëŒ ì¤‘ ë‚˜ë³´ë‹¤ ì‹¤ë ¥ì´ ë‚˜ìœ ì‚¬ëŒì˜ ìˆ˜ë¥¼ ì„¸ëŠ” ë¬¸ì œì´ë‹¤. <br />
ì–¼í• ë³´ë©´ ì‰½ì§€ë§Œ time complexityê°€ O(N^2)ë³´ë‹¤ ì‘ì•„ì•¼ í†µê³¼í•  ìˆ˜ ìˆë‹¤. <br />
ì˜¤ë˜ì „ì— ë°°ìš´ê±°ë¼ ê¹Œë¨¹ì—ˆë˜ mergesortë¥¼ ì‘ìš©í•´ì•¼ í’€ ìˆ˜ ìˆëŠ” ë¬¸ì œë‹¤. <br />
(mergesortëŠ” O(NlogN))ì´ë‹¤. <br />
Mergesortë¥¼ ìš”ì•½í•´ë³´ì.</p>

<ol>
  <li>divide (O(N))
ë°°ì—´ì˜ ì›ì†Œë¥¼ í•˜ë‚˜ì”© ë¶„ë¦¬í•œë‹¤.</li>
  <li>merge (O(NlogN))
ì¸ì ‘í•œ ì›ì†Œë¥¼ ë¹„êµí•˜ë©° í•©ì¹œë‹¤.</li>
</ol>

<p>Divide í›„ mergeí•  ë•Œ, ê·¸ ì¤‘ì— ë’¤ ê·¸ë£¹ì˜ ì›ì†Œë¥¼ í•©ì¹  ë•Œ ì• ê·¸ë£¹ì—ì„œ ëª‡ ê°œì˜ ì›ì†Œê°€ mergeë˜ì—ˆëŠ”ì§€ countí•˜ë©´ ëœë‹¤. <br />
ê° ì›ì†Œë³„ë¡œ ê³„ì‚°í•œ ëˆ„ì  countë¥¼ ì²˜ìŒ indexì—ì„œ ë¹¼ë©´ ì›í•˜ëŠ” ë‹µì„ êµ¬í•  ìˆ˜ ìˆë‹¤.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mergeSort(0, players.length - 1);

for (Player p : players) {
    answer[p.original - 1] = p.original - p.frontNum;
}

public static void mergeSort(int start, int end) {
    if (start &lt; end) {
        int mid = (start + end) / 2;
        mergeSort(start, mid);
        mergeSort(mid + 1, end);
        merge(start, mid, end);
    }
}

public static void merge(int start, int mid, int end) {
    int frontPtr = start;
    int backPtr = mid + 1;
    int idx = start;
    int frontNum = 0;

    while (frontPtr &lt;= mid &amp;&amp; backPtr &lt;= end) {
        if (players[frontPtr].capacity &lt; players[backPtr].capacity) {
            frontNum++;
            Player p = players[frontPtr];
            tmp[idx++] = new Player(p.capacity, p.original, p.frontNum);
            frontPtr++;
        } else {
            Player p = players[backPtr];
            tmp[idx++] = new Player(p.capacity, p.original, p.frontNum + frontNum);
            backPtr++;
        }
    }
    while (frontPtr &lt;= mid) {
        frontNum++;
        Player p = players[frontPtr];
        tmp[idx++] = new Player(p.capacity, p.original, p.frontNum);
        frontPtr++;
    }
    while (backPtr &lt;= end) {
        Player p = players[backPtr];
        tmp[idx++] = new Player(p.capacity, p.original, p.frontNum + frontNum);
        backPtr++;
    }
    for (int i = start; i &lt;= end; i++) {
        players[i] = tmp[i];
    }
}

class Player {
    int capacity;
    int original;
    int frontNum;

    public Player(int capacity, int original, int frontNum) {
        this.capacity = capacity;
        this.original = original;
        this.frontNum = frontNum;
    }

    @Override
    public String toString() {
        return "Player [capacity=" + capacity + ", frontNum=" + frontNum + ", original=" + original + "]";
    }
}
</code></pre></div></div>

<p>ì†”ì§íˆ mergesort ìŠê³ ìˆì–´ì„œ ë„ì €íˆ ëª»í’€ê² ë‹¤ ìƒê°í–ˆë˜ ë¬¸ì œë‹¤. <br />
mergesortë§ê³  ë‹¤ë¥¸ ë°©ë²•ì´ ìˆë‹¤ëŠ”ë° ë“£ê³ ë„ ê¹Œë¨¹ì—ˆë‹¤. <br />
ì´ ë°©ë²• ì•„ë‹ˆë©´ í†µê³¼í•  ìˆ˜ ì—†ì–´! ê°™ì€ ëŠë‚Œì˜ ë¬¸ì œë“¤ì€ ë§ì€ ë¬¸ì œë¥¼ í’€ë©´ì„œ ë‹¤ì–‘í•œ ê²½ìš°ì— ìµìˆ™í•´ì§€ëŠ” ìˆ˜ ë°–ì— ì—†ë‹¤.</p>

:ET