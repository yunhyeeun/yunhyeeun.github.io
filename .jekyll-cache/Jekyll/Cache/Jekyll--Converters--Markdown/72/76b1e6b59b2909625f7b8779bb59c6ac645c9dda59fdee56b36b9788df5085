I"P<p>알고리즘이 문제를 해결하는 방법이라면 시간복잡도는 문제를 해결하는데 걸리는 시간이다. 연산을 몇 번 하는지 계산하면 알고리즘 수행시간을 구할 수 있다. 이는 주로 반복문의 범위나 중첩 반복문으로 계산할 수 있다.</p>

<h2 id="시간복잡도">시간복잡도</h2>

<blockquote>
  <p>시간복잡도(time complexity)는 알고리즘의 수행시간이다.</p>
</blockquote>

<h3 id="time-complexity-표기법">Time complexity 표기법</h3>

<ul>
  <li>big O : worst case</li>
  <li>big omega : best case</li>
  <li>big theta : average case</li>
</ul>

<p>일반적으로 <strong>big-O notation</strong>을 사용한다. <br />
big-O로 표기할 때 <em>최고차항의 차수</em>만을 표기한다.</p>

<h3 id="time-complexity-종류">Time complexity 종류</h3>

<ul>
  <li>O(1)</li>
  <li>O(logN)</li>
  <li>O(N)</li>
  <li>O(NlogN)</li>
  <li>O(N^2)</li>
  <li>O(N^3)</li>
  <li>O(2^N)</li>
  <li>O(N!)</li>
</ul>

<p>예1. binary search : O(logN)</p>

<p>예2. merge sort : O(NlogN) <br />
분할(N) + 병합(NlogN)</p>

<p>예3. 거듭제곱 빠르게 연산 : O(logN)  <br />
지수를 2의 거듭제곱 형태로 나누어 계산</p>

<h3 id="time-complexity-비교">Time complexity 비교</h3>
<p>N이 커질수록 차이가 커진다.</p>

<table>
  <tbody>
    <tr>
      <td>빠름</td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td>느림</td>
    </tr>
  </tbody>
  <tfoot>
    <tr>
      <td>1</td>
      <td>logN</td>
      <td>N</td>
      <td>NlogN</td>
      <td>N^2</td>
      <td>2^N</td>
      <td>N!</td>
    </tr>
  </tfoot>
</table>

<p><br /></p>
<hr />

<h2 id="공간복잡도space-complexity">공간복잡도(Space Complexity)</h2>

<p>공간복잡도는 알고리즘의 메모리 사용량에 관한 지표이다.</p>

<h3 id="자료형-별-메모리-크기java">자료형 별 메모리 크기(java)</h3>

<ul>
  <li>문자형(char) :  2byte</li>
  <li>정수형(short) :  2byte</li>
  <li>정수형(int) : 4byte</li>
  <li>정수형(long) : 8byte</li>
  <li>소수형(float) : 4byte</li>
  <li>소수형(double) : 8byte</li>
</ul>

<h3 id="피보나치-계산">피보나치 계산</h3>

<p>같은 문제여도 어떤 알고리즘을 사용하는지에 따라 time complexity, space complexity가 달라진다. 피보나치 수열을 구하는 문제를 예시로 이를 알아보자.</p>

<ol>
  <li>일반 재귀함수 : O(2^N) <br />
N부터 1까지 역으로 계산하는 방법</li>
  <li>반복문 : O(N) <br />
1부터 계산하는 방법</li>
  <li>dynamic programming : O(N) <br />
2번의 중간결과값을 저장 (미리 저장된 값의 경우 O(1))</li>
  <li>행렬의 거듭제곱 : O(logN)</li>
</ol>

<h2 id="예시-문제-1">예시 문제 1</h2>

<p><a href="https://www.acmicpc.net/problem/2003">백준 2003번 수들의 합2</a></p>

<p>문제 설명대로 수열의 부분합을 구하면 time complexity는 O(N^2)이다. <strong>투포인터</strong>를 사용하면 이를 줄일 수 있다. 문제풀이에 핵심적인 요소를 정리해보았다.</p>

<ul>
  <li>low index pointer와 high index pointer를 지정한다.</li>
  <li>수열은 오름차순으로 정렬된 상태이다</li>
  <li>부분합이 target보다 작으면 high pointer를 증가시킨다.</li>
  <li>부분합이 target보다 크면 low pointer를 증가시킨다.</li>
  <li>high pointer가 범위를 벗어날 때까지 반복한다.</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>while (high &lt; N) {
    // 부분합이 target보다 작을 때
    if (sum &lt; M) {
        // high pointer 증가
        high++;
        if (high == N) break;
        sum += array[high];
    } else if (sum == M) {
        answer++;
        high++;
        if (high == N) break;
        sum += array[high];
    }
    // 부분합이 target보다 클 때
    else {
        sum -= array[low];
        // low pointer 증가
        low++;
        if (low &gt; high) {
            high++;
            if (high == N) break;
            sum = array[high];
        }
    }
}

</code></pre></div></div>

<p>유사한 문제 <a href="https://www.acmicpc.net/problem/1806">백준 1806번 부분합</a></p>

<h2 id="예시-문제-2">예시 문제 2</h2>

<p><a href="https://www.acmicpc.net/problem/2805">백준 2805번 나무자르기</a></p>
<ul>
  <li>binary search</li>
</ul>

<p>[백준 2143번 두 배열의 합]</p>
<ul>
  <li>초기 : N^4</li>
  <li>발전1) 부분합을 저장한 배열 만들어 정렬 : N^2
    <ul>
      <li>투포인터 (lowerbound &amp; upper bound) : 정렬 필수</li>
      <li>lower bound : 찾고자하는 값 이상이 처음 나타나는 위치</li>
      <li>upper bound : 찾고자하는 값보다 큰 값이 처음으로 나타나는 위치</li>
    </ul>
  </li>
  <li>
    <p>발전2) lower bound, upper bound를 T-부분합배열[i]에 대해 binary search로 계산 : NlogN</p>
  </li>
  <li>답이 int maxvalue를 초과하기 때문에 long으로 정의</li>
</ul>

<p>[백준 2517번 달리기]</p>
<ul>
  <li>보통 N^2 -&gt; 시간초과</li>
  <li>inversion count(merge sort 사용) : NlogN</li>
  <li>뒷 블럭을 합칠 때 자기 턴 직전 몇 개의 블럭이 이미 합쳐졌는지 카운트 (앞 블럭은 카운트 x)</li>
  <li>누적 카운트를 초기 index에서 빼면 정답</li>
</ul>

:ET