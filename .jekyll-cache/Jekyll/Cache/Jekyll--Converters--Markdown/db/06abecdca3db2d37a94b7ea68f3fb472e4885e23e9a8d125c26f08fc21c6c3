I"4<p>코테 연습을 이제껏 파이썬으로 했었는데 자바로 연습하려 한다. 최근 수업에 사용한 언어가 파이썬이어서 파이썬을 사용했을 뿐 원래는 자바 실력을 계속 향상시키려 했다. 오랜만에 자바를 써서 구현 속도도 느리고 효율성은 커녕 정확한 코드를 짜기도 버거웠다.</p>

<blockquote>
  <p>완전 탐색은 모든 경우의 수를 탐색하는 방법이다.</p>
</blockquote>

<p>완전 탐색은 효율성이 떨어진다고 볼 수 있지만 답을 찾을 수 있는 확실한 방법이다. DFS와 BFS는 그런 경우(경로)를 탐색하는 방법이다. 항상 헷갈렸던 DFS, BFS로 자바를 연습했다.</p>

<h2 id="dfs-vs-bfs">DFS vs BFS</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">종류</th>
      <th style="text-align: center">DFS</th>
      <th style="text-align: center">BFS</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">뜻</td>
      <td style="text-align: center">깊이 우선 탐색</td>
      <td style="text-align: center">너비 우선 탐색</td>
    </tr>
    <tr>
      <td style="text-align: center">구현 방법</td>
      <td style="text-align: center">재귀함수(stack)</td>
      <td style="text-align: center">queue</td>
    </tr>
    <tr>
      <td style="text-align: center">활용</td>
      <td style="text-align: center">백트랙킹</td>
      <td style="text-align: center">최단경로</td>
    </tr>
    <tr>
      <td style="text-align: center">특징</td>
      <td style="text-align: center">동시 변화 적용 x</td>
      <td style="text-align: center">동시 변화 적용 o</td>
    </tr>
  </tbody>
</table>

<h2 id="pseudocode">Pseudocode</h2>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// DFS에서 체크인과 체크아웃의 indent는 같아야함
function dfs() {
    1. 체크인
    2. 목적지인가?
    3. 갈 수 있는 곳 순회
    4.   갈 수 있는가?
    5.     간다
    6. 체크아웃
}

// BFS를 실행하기 전 시작점을 큐에 넣고 큐가 empty일 때까지 BFS 반복
function bfs() {
    1. 큐에서 꺼내옴
    2. 목적지인가?
    3. 갈 수 있는 곳 순회
    4.   갈 수 있는가?
    5.     체크인
    6.     큐에 넣음
}
</code></pre></div></div>

<h2 id="완전-탐색">완전 탐색</h2>
<p>완전 탐색은 재귀 함수로 구현된다. 재귀 함수를 구현할 때 중요한 포인트를 몇 개 찝어보았다.</p>

<ol>
  <li>하나의 큰 문제를 여러 개의 작은 문제로 나누기</li>
  <li>각 작은 문제를 정의하기 위한 <strong>상태 정보</strong> 설계하기</li>
  <li>각 작은 문제의 상태가 원하는 정답인지(<strong>종결 여부</strong>) 판별하는 조건 설계하기</li>
  <li>각 작은 문제에서 다음 하위 문제를 <strong>탐색할 조건</strong> 설계하기</li>
</ol>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function recursion(StateParameters) {
    if (terminationCondition) {
        return;
    }
    else {
        while (searchCondition) {
            recursion(Parameters);
        }
    }
}
</code></pre></div></div>

<h2 id="문제-풀기">문제 풀기</h2>

<p>위 pseudocode를 사용해서 문제를 풀어보자. <br />
<del>(문제 설명은 생략한다.)</del></p>

<p><a href="https://www.acmicpc.net/problem/1062">백준 1062번 가르침 - DFS</a></p>

<p>모든 단어에 a, c, i, n, t가 들어가므로 K가 5보다 작으면 단어를 하나도 읽을 수 없다. <br />
물론 K가 알파벳 수인 26 이상이면 모든 단어를 읽을 수 있다. <br />
<br />
위 특수한 경우를 제외하고 이 문제를 완전 탐색으로 어떻게 풀 수 있을까 생각해보자.</p>
<ol>
  <li>알파벳 26개 중에 K개를 선택하는 모든 경우의 수를 찾고</li>
  <li>각 case에서 주어진 단어 중 몇 개를 읽을 수 있는지 세고</li>
  <li>그 최댓값을 update하면 된다. <br />
<br /></li>
</ol>

<p>시간이 오래 걸리지 않을까, 효율성이 떨어지지 않을까, 이런 생각하지 말고 우선 구현해보자. <br />
핵심만 꼽으면 이렇다.</p>
<ul>
  <li>모든 경우의 수를 찾을 때 DFS를 사용했다.</li>
  <li>DFS 구현은 재귀함수로 했다.</li>
  <li>경로에 포함된 알파벳 정보를 boolean array인 visited에 저장했다.</li>
  <li>DFS의 상태 정보는 visited의 index다.</li>
  <li>DFS의 종결 조건은 visited에서 true의 개수가 K일 때이다.</li>
  <li>탐색 조건은 visited가 false일 때이다. <br />
<br /></li>
</ul>

<p>중요 흐름은 이렇다.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 처음 a,c,i,n,t에 해당하는 visited는 true로 설정
public static void main(String[] args) {

    int answer = countWords();
    for (int i = 0;i &lt; 26; i++) {
        if (visited[i] == false) {
            dfs(i);					
        }
    }
    // 정답
    System.out.println(answer);
}

// count는 글로벌 변수
public static void dfs(int current) {
    // 1. 체크인
    visited[current] = true;
    count ++;
    // 2. 목적지인가?
    if (count == K) {
        answer = Math.max(answer, countWords());	
    }
    else {
        // 3. 갈 수 있는 곳 순회
        for (int i = current + 1; i &lt; 26; i++) {
            // 4. 갈 수 있는가?
            if (visited[i] == false) {
                // 5. 간다
                dfs(i);
            }
        }
    }
    // 6. 체크아웃
    visited[current] = false;
    count--;
}

// words는 입력받은 단어들을 저장한 글로벌 배열
public static int countWords() {
    int tmp = 0;
    for (int i = 0;i &lt; N;i++) {
        String word = words[i];
        boolean flag = true;
        for (int j = 0;j &lt; word.length();j++) {
            if (visited[word.charAt(j) - 'a'] == false) {
                flag = false;
                break;
            }
        }
        if (flag) {
            tmp ++;
        }
    }
    return tmp;
}
</code></pre></div></div>

<p>위 세 함수 중 dfs 함수가 DFS pseudocode에 맞추어 구현된 함수이다. <br />
DFS 함수를 만들 때 <strong>체크인과 체크아웃을 같은 indent로 맞추면 디버깅이 편하다</strong>. <br />
그외 특별한 점은 for loop 조건 특성상 알파벳 순서대로 순회하여 이전 알파벳은 이미 탐색된 글자이다. 따라서 <strong>3. 갈 수 있는 곳 순회</strong>에서 0부터가 아닌 curent+1에서 시작해도 무방하다.
<br /> <br />
***</p>

<p><a href="https://www.acmicpc.net/problem/3055">백준 3055번 탈출 - BFS</a> <br />
<del>이 문제 포기하고 싶었다</del></p>

<p>DFS가 BFS보다 머리 속으로 그리기 쉬워서 DFS를 선호한다. 최단경로 구하는 문제일 경우 BFS로 찾고 break하는 것이 효율성이 좋지만 DFS로 불가능하진 않다. 그러나 DFS를 쓸 수 없는 문제가 간혹 있다. 이 문제가 그렇다.</p>

<p>위 표에 적은 것처럼 고슴도치와 물이 동시에 이동할 때는 DFS를 사용할 수 없다.</p>

:ET