I"<p>알고리즘이 문제를 해결하는 방법이라면 시간복잡도는 문제를 해결하는데 걸리는 시간이다. 연산을 몇 번 하는지 계산하면 알고리즘 수행시간을 구할 수 있다. 이는 주로 반복문의 범위나 중첩 반복문으로 계산할 수 있다.</p>

<blockquote>
  <p>시간복잡도(time complexity)는 알고리즘의 수행시간이다.</p>
</blockquote>

<h3 id="time-complexity-표기법">Time complexity 표기법</h3>

<ul>
  <li>big O : worst case</li>
  <li>big omega : best case</li>
  <li>big theta : average case</li>
</ul>

<p>일반적으로 big-O notation을 사용한다. <br />
big-O로 표기할 때 <em>최고차항의 차수</em>만을 표기한다.</p>

<h3 id="time-complexity-종류">Time complexity 종류</h3>

<ul>
  <li>O(1)</li>
  <li>O(logN)</li>
  <li>O(N)</li>
  <li>O(NlogN)</li>
  <li>O(N^2)</li>
  <li>O(N^3)</li>
  <li>O(2^N)</li>
  <li>O(N!)</li>
</ul>

<p>예1. binary search : O(logN)</p>

<p>예2. merge sort : O(NlogN) <br />
분할 : N + 병합 : N * logN</p>

<p>예3. 거듭제곱 빠르게 연산 : O(logN)  <br />
지수를 2의 거듭제곱 형태로 나누어 계산</p>

<h3 id="time-complexity-비교">Time complexity 비교</h3>
<p>N이 커질수록 차이가 커진다.</p>

<table>
  <tbody>
    <tr>
      <td>빠름</td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td>느림</td>
    </tr>
  </tbody>
  <tfoot>
    <tr>
      <td>1</td>
      <td>logN</td>
      <td>N</td>
      <td>NlogN</td>
      <td>N^2</td>
      <td>2^N</td>
      <td>N!</td>
      <td> </td>
    </tr>
  </tfoot>
</table>

<h3 id="공간복잡도space-complexity">공간복잡도(Space Complexity)</h3>

<p>알고리즘의 메모리 사용량</p>

<ul>
  <li>문자형 : char 1~2byte</li>
  <li>정수형 : short 2byte</li>
  <li>정수형 : int 4byte</li>
  <li>정수형 : long long(long) 8byte</li>
  <li>소수형 : float 4byte</li>
  <li>소수형 : double 8byte</li>
</ul>

<h3 id="예시-피보나치-계산">예시 피보나치 계산</h3>

<p>[백준 2003번 수들의 합2]</p>

<p>투포인터 (low &amp; high) : 정렬 필수</p>

<p>유사 문제 [백준 1806번 부분합]</p>

<p>[백준 2805번 나무자르기]</p>
<ul>
  <li>binary search</li>
</ul>

<p>[백준 2143번 두 배열의 합]</p>
<ul>
  <li>초기 : N^4</li>
  <li>발전1) 부분합을 저장한 배열 만들어 정렬 : N^2
    <ul>
      <li>투포인터 (lowerbound &amp; upper bound) : 정렬 필수</li>
      <li>lower bound : 찾고자하는 값 이상이 처음 나타나는 위치</li>
      <li>upper bound : 찾고자하는 값보다 큰 값이 처음으로 나타나는 위치</li>
    </ul>
  </li>
  <li>
    <p>발전2) lower bound, upper bound를 T-부분합배열[i]에 대해 binary search로 계산 : NlogN</p>
  </li>
  <li>답이 int maxvalue를 초과하기 때문에 long으로 정의</li>
</ul>

<p>[백준 2517번 달리기]</p>
<ul>
  <li>보통 N^2 -&gt; 시간초과</li>
  <li>inversion count(merge sort 사용) : NlogN</li>
  <li>뒷 블럭을 합칠 때 자기 턴 직전 몇 개의 블럭이 이미 합쳐졌는지 카운트 (앞 블럭은 카운트 x)</li>
  <li>누적 카운트를 초기 index에서 빼면 정답</li>
</ul>

:ET