I"h	<blockquote>
  <p>Data structure는 효율적으로 접근하고 수정할 수 있도록 데이터를 구성하고 저장하는 방법을 말한다.</p>
</blockquote>

<ul>
  <li>
    <p>선형 구조 : 데이터가 일렬로 나열
  array, linked list, stack, queue</p>
  </li>
  <li>
    <p>비선형 구조 : 데이터가 특정한 형태를 띄고 있음</p>
    <ul>
      <li>tree, graph</li>
    </ul>
  </li>
</ul>

<ol>
  <li>array
    <ul>
      <li>접근이 쉬움</li>
      <li>insert/delete가 어려움</li>
    </ul>
  </li>
  <li>linked list
    <ul>
      <li>접근이 느림</li>
      <li>insert/delete가 쉬움</li>
      <li>prev/next에 대한 포인터 필요</li>
    </ul>
  </li>
  <li>stack
    <ul>
      <li>나중에 삽입된 데이터가 먼저 삭제되는 구조 (LIFO)</li>
      <li>top 위치에 새로운 데이터를 삽입</li>
    </ul>
  </li>
  <li>queue
    <ul>
      <li>먼저 삽입된 데이터가 먼저 삭제되는구조 (FIFO)</li>
      <li>front(head) : 삭제될 위치</li>
      <li>rear(tail) : 삽입된 위치</li>
    </ul>
  </li>
  <li>tree
    <ul>
      <li>parent-child relationship</li>
      <li>root node : 최상위 노드</li>
      <li>depth : root에서 해당 노드까지 도달하는데 사용하는 간선의 개수</li>
    </ul>
  </li>
</ol>

<ul>
  <li>
    <p>binary tree : 모든 노드의 child 개수가 2개 이하(left child, right child)</p>
  </li>
  <li>
    <p>array로 binary tree 구현 가능</p>
  </li>
</ul>

<class로 tree="" 구현하기="">
```
class Node {
    Object data
    Node left_child, right_child
}
```
<array로 tree="" 구현하기="">
1. root node를 array[1]에 저장
2. 임의의 parent node의 index를 p라고 하자
3. left child의 index는 2p
4. right child의 index는 2p+1


## binary tree iteration

1. pre-order : current node -&gt; left child -&gt; right child

2. in-order : left child -&gt; current node -&gt; right child

3. post-order : left child -&gt; right child -&gt; current node

## heap

heap : complete binary tree + (parent node value &gt; child node value) or (parent node value &lt; child node value)

## indexed tree

## trie
- 문자열을 빠르게 검색할 수 있는 구조
- K진 tree
- root는 항상 공백 상태

 ### 구현
 class Node {
     Object data
     Node child[]
 }

 ### 탐색
 첫 글자부터 트라이 탐색


</array로></class로>
:ET