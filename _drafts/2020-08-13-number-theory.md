---
title: 정수론
categories: 
    - Develop
tags:
    - 
    - java
    - baekjoon
---

유클리드 호제법 : 두 수의 최대공약수를 구할 수 있는 방법

2개의 자연수 a, b에 대해서 a를 b로 나눈 나머지를 r이라 하면 (a > b)
a, b의 최대공약수는 b와 r의 최대공약수와 같다
gcd(a, b) = gcd(b, r) (r = a % b)
          = gcd(r, 0) (0이 될 때까지 반복)
이때 r이 최대공약수


부정 방정식 : 해가 무수히 많은 방정식
ax + by = c (예. 3x + 2y = 5)

베주 항등식 : ax + by = gcd(a, b)는 항상 해를 갖고 있다.
-> 확장 유클리드 호제법 사용

확장 유클리드 호제법

ax + by = c를 만족하는 x, y를 각각 s, t라고 하자.
이 때 (s, t) = (1,0), (s,t) = (0,1) 일 경우 c 자리에 각각 a, b가 들어온다.
c 자리에 유클리드 호제법을 반복한다.
c 자리에 0이 들어온다면 바로 전 c 자리에 있는 값으로 ax + by = c를 만족하는 특수해를 찾는다.
(바로 전 c 자리에 있는 값은 a와 b의 최대공약수이다)
(만약 ax + by = c를 만들 수 없다면 해가 없는 식이다)

특수해를 이용하여 일반해 식을 구하면 아래와 같다.

x = x0 + B / D * K
y = y0 - A / D * K

(x, y : 일반해, x0, y0 : 특수해, D : gcd(a, b), K : const)

*유도방법*

ax0 + by0 = c
ax1 + by1 = c

두 식에 ab / D - ab / D = 0을 더한다
a(x0 + b / D) + b(y0 - a / D) = 0


소수

1보다 큰 정수 p의 약수가 1과 p뿐인 수

소수 구하는 법
1. 루트N까지 계산해서 약수가 없으면 소수
2. 에라토스테네스의 체
 - N 크기의 배열 만들기
 - 2부터 루트N까지 계산
 - 소수라면 그 수의 배수들을 모두 체크
 - 체크된 값은 소수가 아님

서로소 : 두 수가 1 이외의 양의 공약수를 가지지 않는 경우
어떤 수 N에 대해 N보다 작으면서 N과 서로소인 수의 개수를 pi(N)이라고 하자.
이 때 소수인 n의 pi(n) = n - 1을 만족한다
이 때 소수의 거듭제곱인 p^n의 pi(p^n) = p^n - p^(n-1)
이 때 소수가 아닌 수 n(a * b)의 pi(n) = pi(a) * pi(b), a와 b는 서로소





